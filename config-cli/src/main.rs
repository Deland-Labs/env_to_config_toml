use clap::Parser;
use env_file_reader::read_file;
use glob::glob;
use log::{debug, info, LevelFilter, trace};
use simple_logger::SimpleLogger;
use std::collections::{HashMap};

use std::fs::{read_to_string, File};
use std::io::{Cursor, Write};


/// Merge multiple .env files into one
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// The directory containing .env files
    #[arg(short, long)]
    pattern: String,

    /// The output file to write the merged .env file to
    #[arg(short, long)]
    out_path: std::path::PathBuf,

    /// Optional Log Level (0 = info, 1 = debug, 2 = trace)
    #[arg(short, long, default_value_t = 0)]
    log_level: u8,
}

fn main() {
    let args = Args::parse();
    args.init_log();
    match args.get_merge_bytes() {
        Ok(bytes) => {
            let mut file = File::create(args.get_out_path()).unwrap();
            file.write_all(&bytes).unwrap();
            info!("merge env files success");
        }
        Err(e) => info!("merge env files failed: {}", e),
    }
}

const END: &str = "\n# GENERATED BY ENV_TO_CONFIG_TOML END\n";
const START: &str = "# GENERATED BY ENV_TO_CONFIG_TOML START\n";

impl Args {
    pub fn init_log(&self) {
        let log_level = match self.log_level {
            0 => LevelFilter::Info,
            1 => LevelFilter::Debug,
            2 => LevelFilter::Trace,
            _ => LevelFilter::Debug,
        };
        SimpleLogger::new().with_level(log_level).init().unwrap();
    }

    pub fn get_out_path(&self) -> &std::path::PathBuf {
        &self.out_path
    }

    pub fn get_merge_bytes(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let env_vars = self.get_env_vars()?;

        return match self.out_path.exists() {
            true => {
                debug!("Merging into existing file: {:?}", self.out_path);
                let result = self.merge_existing_toml(&env_vars)?;
                Ok(result)
            }
            false => {
                debug!("Creating new file in: {:?}", self.out_path);
                let parent = self
                    .out_path
                    .parent()
                    .expect("Failed to get parent directory");
                if !parent.exists() {
                    debug!("Creating parent directory: {:?}", parent);
                    std::fs::create_dir_all(parent)?;
                }

                let mut writer = Cursor::new(Vec::new());
                writer.write_all(START.as_bytes())?;
                writer.write_all(b"\n[env]\n")?;
                for (key, value) in &env_vars {
                    writer.write_all(format!("{} = \"{}\"\n", key, value).as_bytes())?;
                }
                writer.write_all(END.as_bytes())?;

                Ok(writer.into_inner())
            }
        };
    }

    fn get_env_vars(&self) -> Result<Vec<(String, String)>, Box<dyn std::error::Error>> {
        let mut env_paths: Vec<std::path::PathBuf> = glob(&self.pattern)
            .expect("Failed to read glob pattern")
            .filter_map(Result::ok)
            .filter(|path| path.is_file())
            .collect();
        if env_paths.is_empty() {
            return Err(format!("Pattern is Invalid: {}", self.pattern).into());
        }

        env_paths.sort_by_key(|path| path.to_str().unwrap().to_lowercase());
        let mut env_vars = HashMap::new();
        for env_path in env_paths {
            info!("Reading env file: {:?}", env_path);
            let env = read_file(env_path.clone())?;
            for (key, value) in env {
                let value = value
                    .trim()
                    .lines()
                    .filter(|s| !s.starts_with("#"))
                    .collect::<Vec<_>>()
                    .join("||||");
                if env_vars.contains_key(&key) {
                    return Err(format!("Duplicate key found: {} in {:?}", key, env_path).into());
                }
                env_vars.insert(key, value);
            }
        }
        let mut env_vars: Vec<_> = env_vars
            .iter()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect();
        env_vars.sort_by_key(|(key, _)| key.to_lowercase());
        Ok(env_vars)
    }

    fn merge_existing_toml(
        &self,
        env_vars: &[(String, String)],
    ) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let file_content = read_to_string(self.out_path.clone())?;
        let mut config: toml::Value = toml::from_str(&file_content)?;
        let table = config.as_table_mut().unwrap();

        let env_table = table
            .entry("env".to_owned())
            .or_insert_with(|| {
                debug!("Creating new [env] section");
                toml::Value::Table(toml::value::Table::new())
            })
            .as_table_mut()
            .expect("Invalid TOML file: missing [env] section");

        for (key, value) in env_vars {
            if env_table.contains_key(key) {
                debug!("Updating env var: {}={}", key, value);
                trace!("Old value: {:?}", env_table.get(key));
            } else {
                debug!("Adding env var: {}={}", key, value);
            }
            env_table.insert(key.to_owned(), toml::Value::String(value.to_owned()));
        }
        let env_line_count = env_table.len();
        let env_section_index = {
            let config_table = config.as_table().unwrap();
            let mut index = 0;
            for (key, _) in config_table.iter() {
                if key == "env" {
                    break;
                }
                index += 1;
            }
            index
        };

        let toml_str = toml::to_string_pretty(&config)?;
        let mut lines: Vec<&str> = toml_str.lines().collect();
        lines.insert(env_section_index, START);
        lines.insert(env_section_index + env_line_count + 2, END);
        let toml_str = lines.join("\n");

        let mut writer = Cursor::new(Vec::new());
        writer.write_all(toml_str.as_bytes())?;
        Ok(writer.into_inner())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    #[test]
    fn test_merge_env_files_new() {
        let out = Path::new("src/test_data/new_config.toml");
        let pattern = "src/test_data/[0-9].env";
        let _ = std::fs::remove_file(out);
        let args = Args {
            pattern: pattern.to_owned(),
            out_path: out.to_owned(),
            log_level: 0,
        };

        let bytes = args.get_merge_bytes().unwrap();
        let config_content = String::from_utf8(bytes).unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/new_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_new_folder() {
        let out = Path::new("src/test_data/new_folder/new_folder_config.toml");
        let _ = std::fs::remove_file(out);
        let _ = std::fs::remove_dir("src/test_data/new_folder");
        let pattern = "src/test_data/[0-9].env";
        let args = Args {
            pattern: pattern.to_owned(),
            out_path: out.to_owned(),
            log_level: 0,
        };

        let bytes = args.get_merge_bytes().unwrap();
        let config_content = String::from_utf8(bytes).unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/new_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_exist() {
        let pattern = "src/test_data/[0-9].env";
        let out = Path::new("src/test_data/exist_config.toml");
        let _ = std::fs::copy("src/test_data/old.toml", out).unwrap();
        let args = Args {
            pattern: pattern.to_owned(),
            out_path: out.to_owned(),
            log_level: 0,
        };

        let bytes = args.get_merge_bytes().unwrap();
        let config_content = String::from_utf8(bytes).unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/old_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_overwrite() {
        let out = Path::new("src/test_data/overwrite_config.toml");
        let _ = std::fs::copy("src/test_data/overwrite.toml", out).unwrap();
        let pattern = "src/test_data/[0-9].env";
        let args = Args {
            pattern: pattern.to_owned(),
            out_path: out.to_owned(),
            log_level: 0,
        };
        let bytes = args.get_merge_bytes().unwrap();
        let config_content = String::from_utf8(bytes).unwrap();
        let verify_content =
            std::fs::read_to_string("src/test_data/overwrite_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_duplicate() {
        let out = Path::new("src/test_data/duplicate_config.toml");
        let _ = std::fs::copy("src/test_data/overwrite.toml", out).unwrap();
        let pattern = "src/test_data/*.env";
        let args = Args {
            pattern: pattern.to_owned(),
            out_path: out.to_owned(),
            log_level: 0,
        };
        let result = args.get_merge_bytes();
        assert!(result.is_err());
    }
}