use env_file_reader::read_file;
use glob::glob;
use std::env;
use std::fs::{read_to_string, write, File};
use std::io::{BufWriter, Write};
use std::path::Path;
use log::{debug, info, LevelFilter};
use simple_logger::SimpleLogger;

fn main() {
    let log_level = LevelFilter::Debug;
    SimpleLogger::new()
        .with_level(log_level)
        .init()
        .unwrap();


    let matches = clap::Command::new("merge")
        .about("Merge multiple .env files into one")
        .arg(
            clap::arg!(--"pattern" <PATH>)
                .required(true)
                .help("The directory containing .env files")
                .value_parser(clap::value_parser!(String)),
        )
        .arg(
            clap::arg!(--"out-path" <PATH>)
                .required(true)
                .help("The output file to write the merged .env file to")
                .value_parser(clap::value_parser!(std::path::PathBuf)),
        ).get_matches();
    let pattern = matches.get_one::<String>("pattern").unwrap();
    let out = matches.get_one::<std::path::PathBuf>("out-path").unwrap();
    match merge_env_files(pattern, out) {
        Ok(_) => info!("merge env files success"),
        Err(e) => info!("merge env files failed: {}", e),
    }
}

const END: &str = "\n# GENERATED BY ENV_TO_CONFIG_TOML END\n";
const START: &str = "# GENERATED BY ENV_TO_CONFIG_TOML START\n";

fn merge_env_files(pattern: &str, out_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    let mut env_paths: Vec<std::path::PathBuf> = glob(pattern)
        .expect("Failed to read glob pattern")
        .filter_map(Result::ok)
        .collect();
    env_paths.sort_by_key(|path| path.to_str().unwrap().to_lowercase());
    let env_paths = env_paths;
    let env_vars = read_env_vars(&env_paths)?;

    if out_path.exists() {
        debug!("Merging into existing file: {:?}", out_path);
        merge_existing_toml(out_path, &env_vars)?;
    } else {
        debug!("Creating new file in: {:?}", out_path);
        let parent = out_path.parent().expect("Failed to get parent directory");
        if !parent.exists() {
            debug!("Creating parent directory: {:?}", parent);
            std::fs::create_dir_all(parent)?;
        }

        let file = File::create(out_path)?;
        let mut writer = BufWriter::new(&file);
        writer.write_all(START.as_bytes())?;
        writer.write_all(b"[env]\n")?;
        for (key, value) in &env_vars {
            writer.write_all(format!("{} = \"{}\"\n", key, value).as_bytes())?;
        }
        writer.write_all(END.as_bytes())?;
    };
    info!("Output file: {:?}", out_path);
    Ok(())
}

fn read_env_vars(env_paths: &[std::path::PathBuf]) -> Result<Vec<(String, String)>, Box<dyn std::error::Error>> {
    let mut env_vars = std::collections::HashMap::new();
    for env_path in env_paths {
        info!("Reading env file: {:?}", env_path);
        let env = read_file(env_path)?;
        for (key, value) in env {
            let value = value
                .trim()
                .lines()
                .filter(|s| !s.starts_with("#"))
                .collect::<Vec<_>>()
                .join("||||");
            if env_vars.contains_key(&key) {
                return Err(format!("Duplicate key found: {}", key).into());
            }
            env_vars.insert(key, value);
        }
    }
    let mut env_vars: Vec<_> = env_vars.iter().map(|(k, v)| (k.clone(), v.clone())).collect();
    env_vars.sort_by_key(|(key, _)| key.to_lowercase());
    Ok(env_vars)
}

fn merge_existing_toml(
    toml_path: &Path,
    env_vars: &[(String, String)],
) -> Result<(), Box<dyn std::error::Error>> {
    let file_content = read_to_string(toml_path)?;
    let mut config: toml::Value = toml::from_str(&file_content)?;
    let table = config.as_table_mut().unwrap();

    let env_table = table
        .entry("env".to_owned())
        .or_insert_with(|| {
            debug!("Creating new [env] section");
            toml::Value::Table(toml::value::Table::new())
        })
        .as_table_mut()
        .expect("Invalid TOML file: missing [env] section");

    for (key, value) in env_vars {
        if env_table.contains_key(key) {
            debug!("Updating env var: {}={}", key, value);
        } else {
            debug!("Adding env var: {}={}", key, value);
        }
        env_table.insert(key.to_owned(), toml::Value::String(value.to_owned()));
    }
    let env_line_count = env_table.len();
    let env_section_index = {
        let config_table = config.as_table().unwrap();
        let mut index = 0;
        for (key, _) in config_table.iter() {
            if key == "env" {
                break;
            }
            index += 1;
        }
        index
    };

    let toml_str = toml::to_string_pretty(&config)?;
    let mut lines: Vec<&str> = toml_str.lines().collect();
    lines.insert(env_section_index, START);
    lines.insert(env_section_index + env_line_count + 2, END);
    let toml_str = lines.join("\n");

    let mut writer = BufWriter::new(Vec::new());
    writer.write_all(toml::to_string(&config)?.as_bytes())?;

    write(toml_path, toml_str.as_bytes())?;
    Ok(())
}
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_merge_env_files_new() {
        let out = Path::new("src/test_data/new_config.toml");

        let _ = std::fs::remove_file(out);

        let pattern = "src/test_data/[0-9].env";
        merge_env_files(pattern, out).unwrap();

        let config_content = std::fs::read_to_string(out).unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/new_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_new_folder() {
        let out = Path::new("src/test_data/new_folder/new_folder_config.toml");
        let _ = std::fs::remove_file(out);
        let _ = std::fs::remove_dir("src/test_data/new_folder");


        let pattern = "src/test_data/[0-9].env";
        merge_env_files(pattern, out).unwrap();

        let config_content = std::fs::read_to_string(out).unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/new_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_exist() {
        let _ = std::fs::remove_file("src/test_data/exist_config.toml");
        let _ = std::fs::copy("src/test_data/old.toml", "src/test_data/exist_config.toml").unwrap();

        let pattern = "src/test_data/[0-9].env";
        let out = Path::new("src/test_data/exist_config.toml");
        merge_env_files(pattern, out).unwrap();

        let config_content = std::fs::read_to_string("src/test_data/exist_config.toml").unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/old_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }


    #[test]
    fn test_merge_env_files_overwrite() {
        let out = Path::new("src/test_data/overwrite_config.toml");
        let _ = std::fs::remove_file(out);
        let _ = std::fs::copy("src/test_data/overwrite.toml", out).unwrap();

        let pattern = "src/test_data/[0-9].env";
        let out = Path::new(out);
        merge_env_files(pattern, out).unwrap();

        let config_content = std::fs::read_to_string(out).unwrap();
        let verify_content = std::fs::read_to_string("src/test_data/overwrite_verify.toml").unwrap();
        assert_eq!(config_content, verify_content);
    }

    #[test]
    fn test_merge_env_files_duplicate() {
        let out = Path::new("src/test_data/duplicate_config.toml");
        let _ = std::fs::remove_file("src/test_data/config.toml");
        let _ = std::fs::copy("src/test_data/overwrite.toml", out).unwrap();

        let pattern = "src/test_data/*.env";
        let out = Path::new(out);
        let result = merge_env_files(pattern, out);
        assert!(result.is_err());
    }
}