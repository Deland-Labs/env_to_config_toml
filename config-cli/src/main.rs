use env_file_reader::read_file;
use glob::glob;
use std::env;
use std::fs::{read_to_string, write, File};
use std::io::{BufRead, BufWriter, Write};
use std::path::Path;
use log::{debug, info};

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        println!("Usage: {} <source> <out>", args[0]);
        return;
    }
    let source = &args[1];
    let out = &args[2];
    match merge_env_files(source, out) {
        Ok(_) => info!("merge env files success"),
        Err(e) => info!("merge env files failed: {}", e),
    }
}

const END: &str = "\n# GENERATED BY ENV_TO_CONFIG_TOML END\n";
const START: &str = "# GENERATED BY ENV_TO_CONFIG_TOML START\n";

fn merge_env_files(source: &str, out: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut env_paths: Vec<std::path::PathBuf> = glob(source)
        .expect("Failed to read glob pattern")
        .filter_map(Result::ok)
        .collect();
    env_paths.sort_by_key(|path| path.to_str().unwrap().to_lowercase());

    let env_paths = env_paths;
    let env_vars = read_env_vars(&env_paths)?;

    let toml_path = Path::new(out);
    if toml_path.exists() {
        merge_existing_toml(toml_path, &env_vars)?;
    } else {
        let file = File::create(toml_path)?;
        let mut writer = BufWriter::new(&file);
        writer.write_all(START.as_bytes())?;
        writer.write_all(b"[env]\n")?;
        for (key, value) in &env_vars {
            writer.write_all(format!("{} = \"{}\"\n", key, value).as_bytes())?;
        }
        writer.write_all(END.as_bytes())?;
    };
    info!("Output file: {:?}", toml_path);
    Ok(())
}

fn read_env_vars(env_paths: &[std::path::PathBuf]) -> Result<Vec<(String, String)>, Box<dyn std::error::Error>> {
    let mut env_vars = std::collections::HashMap::new();
    for env_path in env_paths {
        info!("Reading env file: {:?}", env_path);
        let env = read_file(env_path)?;
        for (key, value) in env {
            let value = value
                .trim()
                .lines()
                .filter(|s| !s.starts_with("#"))
                .collect::<Vec<_>>()
                .join("||||");
            if env_vars.contains_key(&key) {
                return Err(format!("Duplicate key found: {}", key).into());
            }
            env_vars.insert(key, value);
        }
    }
    let mut env_vars: Vec<_> = env_vars.iter().map((|(k, v)| (k.clone(), v.clone()))).collect();
    env_vars.sort_by_key(|(key, _)| key.to_lowercase());
    Ok(env_vars)
}

fn merge_existing_toml(
    toml_path: &Path,
    env_vars: &[(String, String)],
) -> Result<(), Box<dyn std::error::Error>> {
    let file_content = read_to_string(toml_path)?;
    let mut config: toml::Value = toml::from_str(&file_content)?;
    let table = config.as_table_mut().unwrap();

    let env_table = table
        .entry("env".to_owned())
        .or_insert_with(|| toml::Value::Table(toml::value::Table::new()))
        .as_table_mut()
        .expect("Invalid TOML file: missing [env] section");

    for (key, value) in env_vars {
        env_table.insert(key.to_owned(), toml::Value::String(value.to_owned()));
    }
    let env_line_count = env_table.len();
    let env_section_index = {
        let config_table = config.as_table().unwrap();
        let mut index = 0;
        for (key, _) in config_table.iter() {
            if key == "env" {
                break;
            }
            index += 1;
        }
        index
    };

    let toml_str = toml::to_string_pretty(&config)?;
    let mut lines: Vec<&str> = toml_str.lines().collect();
    lines.insert(env_section_index, START);
    lines.insert(env_section_index + env_line_count + 2, END);
    let toml_str = lines.join("\n");

    let mut writer = BufWriter::new(Vec::new());
    writer.write_all(toml::to_string(&config)?.as_bytes())?;

    write(toml_path, toml_str.as_bytes())?;
    Ok(())
}

#[test]
fn test_merge_env_files_new() {
    let _ = std::fs::remove_file("src/test_data/config.toml");

    let source = "src/test_data/*.env";
    let out = "src/test_data/config.toml";
    merge_env_files(source, out).unwrap();

    let config_content = std::fs::read_to_string("src/test_data/config.toml").unwrap();
    let verify_content = std::fs::read_to_string("src/test_data/new_verify.toml").unwrap();
    assert_eq!(config_content, verify_content);
}

#[test]
fn test_merge_env_files_exist() {
    let _ = std::fs::remove_file("src/test_data/config.toml");
    let _ = std::fs::copy("src/test_data/old.toml", "src/test_data/config.toml").unwrap();

    let source = "src/test_data/*.env";
    let out = "src/test_data/config.toml";
    merge_env_files(source, out).unwrap();

    let config_content = std::fs::read_to_string("src/test_data/config.toml").unwrap();
    let verify_content = std::fs::read_to_string("src/test_data/old_verify.toml").unwrap();
    assert_eq!(config_content, verify_content);
}

#[test]
fn test_merge_env_files_overwrite() {
    let _ = std::fs::remove_file("src/test_data/config.toml");
    let _ = std::fs::copy("src/test_data/overwrite.toml", "src/test_data/config.toml").unwrap();

    let source = "src/test_data/*.env";
    let out = "src/test_data/config.toml";
    merge_env_files(source, out).unwrap();

    let config_content = std::fs::read_to_string("src/test_data/config.toml").unwrap();
    let verify_content = std::fs::read_to_string("src/test_data/overwrite_verify.toml").unwrap();
    assert_eq!(config_content, verify_content);
}
