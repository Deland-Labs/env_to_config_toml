use std::env;
use std::fs::{File, OpenOptions};
use std::io::{BufRead, BufReader, BufWriter, Seek, Write};
use std::path::Path;
use glob::glob;
use env_file_reader::read_file;

fn main() {
    let args: Vec<String> = env::args().collect();
    if args.len() != 3 {
        println!("Usage: {} <source> <out>", args[0]);
        return;
    }
    let source = &args[1];
    let out = &args[2];
    match merge_env_files(source, out) {
        Ok(_) => println!("merge env files success"),
        Err(e) => println!("merge env files failed: {}", e),
    }
}


fn merge_env_files(source: &str, out: &str) -> Result<(), Box<dyn std::error::Error>> {
    let mut env_files: Vec<std::path::PathBuf> = glob(source)
        .expect("Failed to read glob pattern")
        .filter_map(Result::ok)
        .collect();
    env_files.sort_by_key(|path| path.to_str().unwrap().to_lowercase());

    let env_files = env_files;

    let mut env_vars = std::collections::HashMap::new();
    for env_file in env_files {
        let env_file = read_file(env_file)?;
        for (key, value) in env_file {
            let value = value.trim().lines().filter(|s| !s.starts_with("#")).collect::<Vec<_>>().join("||||");
            env_vars.insert(key, value);
        }
    }
    let mut env_vars : Vec<_> = env_vars.iter().collect();
    env_vars.sort_by_key(|(key, _)| key.to_lowercase());



    let end = "\n# GENERATED BY ENV_TO_CONFIG_TOML END\n";
    let start = "# GENERATED BY ENV_TO_CONFIG_TOML START\n";
    let toml_path = Path::new(out);
    if toml_path.exists() {
        let mut file = OpenOptions::new().read(true).write(true).open(toml_path)?;
        let reader = BufReader::new(&file);
        let mut writer = BufWriter::new(&file);
        let mut found_env_section = false;
        for line in reader.lines() {
            let line = line?;
            if line.trim() == "[env]" {
                found_env_section = true;
                let pos = writer.seek(std::io::SeekFrom::Current(0))?;
                writer.seek(std::io::SeekFrom::Start(pos - end.len() as u64 + 1))?;
                for (key, value) in &env_vars {
                    writer.write_all(format!("{} = \"{}\"\n", key, value).as_bytes())?;
                }
            } else if found_env_section {
                break;
            }
        }
        writer.write_all(end.as_bytes())?;
    } else {
        let mut file = File::create(toml_path)?;
        let mut writer = BufWriter::new(&file);
        writer.write_all(start.as_bytes())?;
        writer.write_all(b"[env]\n")?;
        for (key, value) in &env_vars {
            writer.write_all(format!("{} = \"{}\"\n", key, value).as_bytes())?;
        }
        writer.write_all(end.as_bytes())?;
    };
    Ok(())
}

#[test]
fn test_merge_env_files() {
    //clear up test data
    let _ = std::fs::remove_file("src/test_data/config.toml");

    let source = "src/test_data/*.env";
    let out = "src/test_data/config.toml";
    merge_env_files(source, out).unwrap();

    let config_content = std::fs::read_to_string("src/test_data/config.toml").unwrap();
    let verify_content = std::fs::read_to_string("src/test_data/verify.toml").unwrap();
    assert_eq!(config_content, verify_content);
}